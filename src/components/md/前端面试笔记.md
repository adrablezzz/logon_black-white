

#### 1.预编译习题

​	预编译阶段做的事情:

​		1.创建ao对象

​		2.找形参和变量声明,作为ao对象的属性名,值是undefined

​		3.实参和形参相统一

​		4.找函数声明,会覆盖变量的声明

```js
function fn(a,c) {
    console.log(a) 	//输出: function a() {}
    console.log(c)	//输出: function c() {}
    function a() {}
    function c() {}
}
fn(1,2)
//1
AO: {
    //2,3,4
    a: undefined 1 function a() {} //依次覆盖
    c: undefined 2 function c() {}
}
```

#### 2.this指向题

​	1.在函数中直接使用 (指向 window)

​	2.函数作为对象的方法被调用 (谁调用就指向谁)

​	3.箭头函数没有自己的this, 它的this指向继承父级, 即上一个闭包(ES5)或代码块(ES6)的this,如果都没有才指向window

#### 3.js作用域

​	0.作用域原理: 

​		在函数代码执行前 会预编译 创建一个执行期上下文对象 AO(作用域)

​		在全局代码执行前会创建一个执行期上下文对象 GO(作用域)

​	全局作用域

​		预编译:

​		1.创建GO对象

​		2.找变量声明 将变量名作为GO对象的属性名 值为undefined

​		3.找函数声明 值赋予函数体

​	函数作用域

​		预编译:

​		1.创建AO对象

​		2.找形参和变量声明 作为AO对象的属性名 值是undefined

​		3.实参和形参相统一

​		4.在函数体里面找函数声明 值赋予函数体

​	块级作用域(ES6)

```js
AO: {
    a: undefined 1 function a() {}
    c: undefined 2 function c() {}
    b: undefined   
    d: undefined
}
```

#### 4.闭包的底层理解

​	1.作用域链

```js
scopeChain: [
	AO: {
    	a: 123
    	b: function
    },
    GO: {
        global,
        a: function
    }
]
```

​	2.闭包创建函数作用域, 一直存在内存中 可以被全局访问 用来封装方法

#### 5.防抖函数

```js
debounce(func, delay) {
    let timer = null
    return function (...args) {
        if (timer) clearTimeout(timer)
        timer = setTimeout(() => {
            func.apply(this, args)
        }, delay)
    }
}
```

#### 6.节流函数

```js
function throttle(func, wait) {
    let timeout

    return function() {
        if (!timeout) {
            timeout = setTimeout(() => {
                timeout = null
                func.call(this, arguments)
            }, wait)
        }
    }
}
```

#### 7.图片懒加载原理

​	1.设置图片路径为空或占位图

​	2.当图片offsetTop < 可见高度 + 滚动高度时(图片出现在屏幕中) 将图片的路径进行更换

​	3.使用防抖和节流函数

#### 8.事件循环 

​	1.一般情况下,js代码逐行编译运行, 将函数压入调用栈中 调用一个函数就清除一个函数

​	2.异步操作: fetch setTimeout setInterval 会将消息压入到消息队列中 待调用栈清空 再调用消息栈

​	3.异步操作: promise async await 的异步操作时会加入到微任务中去 会在调用栈清空时立即执行 调用栈中的微任务会立马执行

​	执行优先级: 调用栈 > 微任务 > 消息栈

#### 9.BFC 块级格式化上下文

​	开启BFC是解决的问题: 

​		1.高度塌陷问题

​		2.阻止元素被浮动元素覆盖

​	开启BFC的方式: 

​		1.开启浮动

​		2.position: absolute 或 fixed

​		3.display: inline-block 或 flex 或 inline-flex

​		4.overflow: hidden

#### 10.深浅拷贝

​	1.栈内存和堆内存

​	2.赋值和浅拷贝的区别

​		1.浅拷贝需要创建一个新的对象

​		2.拷贝的值: 对象内部的 基本数据类型的值或引用数据类型的内存地址 即只复制栈内存中的内容

​		3.浅拷贝如果遇到的是引用数据类型 拷贝前后是互相影响的

![](D:\Study\面试\截图\深浅拷贝.png)

![](D:\Study\面试\截图\深浅拷贝图解.png)

​	3.深浅拷贝的代码

```js
//浅拷贝源码
function shallowCopy(src) {
   var dst = {};
   for (var prop in src) {
       if (src.hasOwnProperty(prop)) {
           dst[prop] = src[prop];
       }
   }
   return dst;
}
//浅拷贝方法 Object.assign() | Array.prototype.concat() | Array.prototype.slice()
var initalObj = Object.assign({}, obj); //对象浅拷贝
let arr2=arr.concat(); //数组浅拷贝
let arr3 = arr.slice();//数组浅拷贝

```

​		深拷贝方法: 1. JSON.parse(JSON.stringify())

```js
let arr4 = JSON.parse(JSON.stringify(arr)); //这种方法虽然可以实现数组或对象深拷贝，但不能处理函数。
```

​		2.手写递归方法:	

​			原理：遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝。

```js
   // 定义检测数据类型的功能函数
   function checkedType(target) {
     return Object.prototype.toString.call(target).slice(8, -1)
   }
   // 实现深度克隆---对象/数组
   function clone(target) {
     // 判断拷贝的数据类型
     // 初始化变量result 成为最终克隆的数据
     let result, targetType = checkedType(target)
     if (targetType === 'object') {
       result = {}
     } else if (targetType === 'Array') {
       result = []
     } else {
       return target
     }
     // 遍历目标数据
     for (let i in target) {
       // 获取遍历数据结构的每一项值。
       let value = target[i]
       // 判断目标结构里的每一值是否存在对象/数组
       if (checkedType(value) === 'Object' ||
         checkedType(value) === 'Array') { //对象/数组里嵌套了对象/数组
         // 继续遍历获取到value值
         result[i] = clone(value)
       } else { 
        // 获取到value值是基本的数据类型或者是函数。
         result[i] = value;
       }
     }
     return result
   }

   // 定义检测数据类型的功能函数
   function checkedType(target) {
     return Object.prototype.toString.call(target).slice(8, -1)
   }
   // 实现深度克隆---对象/数组
   function clone(target) {
     // 判断拷贝的数据类型
     // 初始化变量result 成为最终克隆的数据
     let result, targetType = checkedType(target)
     if (targetType === 'object') {
       result = {}
     } else if (targetType === 'Array') {
       result = []
     } else {
       return target
     }
     // 遍历目标数据
     for (let i in target) {
       // 获取遍历数据结构的每一项值。
       let value = target[i]
       // 判断目标结构里的每一值是否存在对象/数组
       if (checkedType(value) === 'Object' ||
         checkedType(value) === 'Array') { 
          // 对象/数组里嵌套了对象/数组
          // 继续遍历获取到value值
         result[i] = clone(value)
       } else { 
         // 获取到value值是基本的数据类型或者是函数。
         result[i] = value;
       }
     }
     return result
   }

```

​		3.函数库lodash

```js
var _ = require('lodash');
var obj2 = _.cloneDeep(obj1);
```

#### 11.symbol 表示唯一值

​	

​	